#include <iostream>
#include <fstream>

#pragma once

// Класс для работы с вводом/выводом
class ReadWriter {
private:

    std::fstream fin;
    std::fstream fout;

public:

    ~ReadWriter() {
        fin.close();
        fout.close();
    }

    ReadWriter() {
        fin.open("input.txt", std::ios::in);
        fout.open("output.txt", std::ios::out);
    }

    int readInt() {
        if (!fin.is_open())
            throw std::ios_base::failure("file not open");

        int n = 0;
        fin >> n;
        return n;
    }

    //This method only fill array. You should create it before call this method.
    void readArray(int *arr, int length) {
        if (!fin.is_open())
            throw std::ios_base::failure("file not open");

        for (int i = 0; i < length; i++)
            fin >> arr[i];
    }

    void writeInt(int n) {
        if (!fout.is_open())
            throw std::ios_base::failure("file not open");
        fout << n << "\n";
    }

    void writeArray(int *arr, int n) {
        if (!fout.is_open())
            throw std::ios_base::failure("file not open");
        for (int i = 0; i < n; i++)
            fout << arr[i] << " ";
    }
};

int numberOfRecursiveCalls = 0;

void qSort(int *numbers, int array_size, int in, int ik) {
    if (in < ik) {
        int i = in, j = ik;
        int x = numbers[i + (j - i) / 2];
        do {
            while (numbers[i] < x) {
                i++;
            }
            while (numbers[j] > x) {
                j--;
            }
            if (i <= j) {
                int temp = numbers[i];
                numbers[i] = numbers[j];
                numbers[j] = temp;
                i++;
                j--;
            }
        } while (i <= j);
        if (in < j) {
            qSort(numbers, array_size, in, j);
            numberOfRecursiveCalls++;
        }
        if (ik > i) {
            qSort(numbers, array_size, i, ik);
            numberOfRecursiveCalls++;
        }
    }
}

int main() {
    ReadWriter rw;

    int *brr = nullptr;
    int n;

    //Ввод из файла
    n = rw.readInt();

    brr = new int[n];
    rw.readArray(brr, n);

    qSort(brr, n, 0, n - 1);

    rw.writeInt(numberOfRecursiveCalls);

    rw.writeArray(brr, n);

    //освобождаем память
    delete[] brr;

    return 0;
}


